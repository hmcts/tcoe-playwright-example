#!/usr/bin/env node
/**
 * Copies the Odhin report generated by Playwright into a target folder
 * and injects coverage + endpoint tabs.
 * No-op if the report is missing.
 */
import fs from "node:fs";
import path from "node:path";

let scanApiEndpoints;
let readCoverageSummary;
let buildCoverageRows;

const truthy = new Set(["1", "true", "yes", "on"]);
const isTruthy = (value) => truthy.has(String(value ?? "").trim().toLowerCase());

const configuredOutput =
  process.env.PW_ODHIN_OUTPUT ??
  process.env.PLAYWRIGHT_REPORT_FOLDER ??
  path.join("test-results", "odhin-report");
const htmlOutput = process.env.PLAYWRIGHT_HTML_OUTPUT ?? "playwright-report";
const configuredTarget =
  process.env.PW_ODHIN_TARGET ??
  process.env.PLAYWRIGHT_REPORT_TARGET ??
  configuredOutput;
const candidateSources = Array.from(
  new Set([configuredOutput, htmlOutput, configuredTarget])
);
const existingSource = candidateSources
  .map((p) => path.resolve(p))
  .find((p) => fs.existsSync(p));
const target = path.resolve(configuredTarget);
const targetRoot = path.dirname(target);
const coverageRoot = path.resolve("coverage");
const coverageTarget = path.join(target, "coverage");
const coverageLinkFlag = process.env.PW_ODHIN_LINK_COVERAGE === "true";
const skipApiEndpoints = isTruthy(process.env.PW_ODHIN_SKIP_API_ENDPOINTS);
const apiEndpointsOutput =
  process.env.PW_API_ENDPOINTS_OUTPUT ??
  process.env.API_ENDPOINTS_REPORT ??
  path.join("coverage", "api-endpoints.json");
const apiRoot = path.resolve(
  process.env.API_TEST_ROOT ?? path.join("playwright-e2e", "tests", "api")
);

async function main() {
  const common = await import("@hmcts/playwright-common");
  ({ scanApiEndpoints, readCoverageSummary, buildCoverageRows } = common);

  try {
    if (!existingSource) {
      console.warn(
        "copy-odhin-report: no odhin/html report found; expected one of: " +
          candidateSources.join(", ")
      );
      process.exit(0);
    }

    const resolvedSource = existingSource;
    const resolvedTarget = target;
    const sourceIsTarget =
      path.resolve(resolvedSource) === path.resolve(resolvedTarget);

    fs.mkdirSync(targetRoot, { recursive: true });
    if (!sourceIsTarget) {
      fs.rmSync(resolvedTarget, { recursive: true, force: true });
      fs.cpSync(resolvedSource, resolvedTarget, { recursive: true, force: true });
    } else if (!fs.existsSync(resolvedTarget)) {
      console.warn(
        `copy-odhin-report: expected report at ${resolvedTarget} but it is missing.`
      );
      process.exit(0);
    }

    if (!skipApiEndpoints) {
      const { endpoints, totalHits } = collectApiEndpoints(apiRoot);
      if (endpoints.length) {
        writeApiEndpoints(apiEndpointsOutput, { endpoints, totalHits });
        injectNodeApiTab(resolvedTarget, endpoints, totalHits);
      }
    }

    if (coverageLinkFlag && fs.existsSync(coverageRoot)) {
      fs.rmSync(coverageTarget, { recursive: true, force: true });
      fs.cpSync(coverageRoot, coverageTarget, { recursive: true, force: true });
      const coverageIndex = renameCoverageIndex(findCoverageIndex(coverageTarget));
      const coverageSummary = readCoverageSummary(
        path.join(coverageTarget, "coverage-summary.json")
      );
      const coverageRows = coverageSummary
        ? buildCoverageRows(coverageSummary.totals)
        : undefined;
      if (coverageIndex) {
        injectCoverageLink(
          resolvedTarget,
          path.relative(resolvedTarget, coverageIndex),
          coverageRows
        );
        injectCoverageTab(
          resolvedTarget,
          path.relative(resolvedTarget, coverageIndex)
        );
      } else {
        console.warn(
          "copy-odhin-report: coverage index not found; skipping coverage block injection."
        );
      }
    }
  } catch (error) {
    console.warn(`copy-odhin-report: ${error.message}`);
    process.exit(0);
  }
}

try {
  await main();
} catch (error) {
  console.warn(
    `copy-odhin-report: ${
      error instanceof Error ? error.message : String(error)
    }`
  );
  process.exit(0);
}

function findCoverageIndex(rootDir) {
  const preferred = path.join(rootDir, "index.html");
  if (fs.existsSync(preferred)) {
    return preferred;
  }
  return undefined;
}

function renameCoverageIndex(indexPath) {
  if (!indexPath) return undefined;
  const newPath = path.join(path.dirname(indexPath), "api-coverage-report.html");
  try {
    fs.renameSync(indexPath, newPath);
    return newPath;
  } catch {
    return indexPath;
  }
}

function injectCoverageLink(reportFolder, relativeCoveragePath, rows) {
  const files = fs
    .readdirSync(reportFolder)
    .filter((f) => f.toLowerCase().endsWith(".html"));
  const rowHtml = rows?.length
    ? rows
        .map((row) => {
          return `<tr>
      <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${row.metric}</td>
      <td class="text-secondary-emphasis">${row.percent}</td>
      <td class="text-secondary-emphasis">${row.covered}</td>
      <td class="text-secondary-emphasis">${row.total}</td>
    </tr>`;
        })
        .join("\n")
    : "";

  const block = `
          <div class="row ms-3 me-3">
            <div class="col-12">
              <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
                <div class="info-box-header">Coverage</div>
                <p class="text-secondary-emphasis small mb-2 ps-2">
                  Scope: totals from coverage-summary.json (all instrumented files in this run). Embedded HTML report may be folder-specific.
                </p>
                <div class="odhin-table">
                  <div class="table-responsive">
                    <table class="table table-sm mb-0 testcase-run-info-table">
                      <thead>
                        <tr>
                          <th class="odhin-text-3">Metric</th>
                          <th class="odhin-text-3">Percent</th>
                          <th class="odhin-text-3">Covered</th>
                          <th class="odhin-text-3">Total</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${
                          rowHtml ||
                          '<tr><td colspan="4" class="text-secondary-emphasis">Summary unavailable</td></tr>'
                        }
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, "utf8");
      if (!html.includes('id="TabDashboard"')) {
        return;
      }
      html = html.replace(
        /<div class="row ms-3 me-3">\s*<div class="col-12[^>]*>\s*<div class="mt-3 mb-3 odhin-thin-border dashboard-block">\s*<div class="info-box-header">Coverage[\s\S]*?<\/div>\s*<\/div>\s*<\/div>\s*<\/div>/m,
        ""
      );

      const tabDashPattern =
        /(<div[^>]+id="TabDashboard"[\s\S]*?)(<\/div>\s*<div[^>]+id="TabTests")/m;
      if (tabDashPattern.test(html)) {
        html = html.replace(
          tabDashPattern,
          (_m, before, after) => `${before}\n${block}\n</div>\n${after}`
        );
      }
      fs.writeFileSync(fullPath, html, "utf8");
    } catch {
      // ignore
    }
  });
}

function injectCoverageTab(reportFolder, relativeCoveragePath) {
  const files = fs
    .readdirSync(reportFolder)
    .filter((f) => f.toLowerCase().endsWith(".html"));
  const tabButton = `
\t\t\t\t\t\t<button
\t\t\t\t\t\t\tclass="main-tablinks"
\t\t\t\t\t\t\tonclick="openMainTab(event, 'TabCoverage')"
\t\t\t\t\t\t>
\t\t\t\t\t\t\tCoverage
\t\t\t\t\t\t</button>`;
  const tabPane = `
<div id="TabCoverage" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Coverage report</div>
          <p class="text-secondary-emphasis small mb-3 ps-2">
            Source: ${relativeCoveragePath} (may be folder-specific).
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <iframe src="${relativeCoveragePath}" style="width:100%;min-height:900px;border:0;"></iframe>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>`;

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, "utf8");
      if (html.includes('id="TabCoverage"')) {
        return;
      }
      const tabBlock =
        /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
      if (tabBlock.test(html)) {
        html = html.replace(tabBlock, `$1${tabButton}$2`);
      }
      html = html.replace("</body>", `${tabPane}\n</body>`);
      fs.writeFileSync(fullPath, html, "utf8");
    } catch {
      // ignore
    }
  });
}

function collectApiEndpoints(rootDir) {
  if (!scanApiEndpoints || !fs.existsSync(rootDir)) {
    return { endpoints: [], totalHits: 0 };
  }
  try {
    return scanApiEndpoints(rootDir, { useAst: true });
  } catch (error) {
    console.warn(
      `copy-odhin-report: endpoint scan failed: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
    return { endpoints: [], totalHits: 0 };
  }
}

function writeApiEndpoints(outputPath, result) {
  try {
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(result, null, 2), "utf8");
  } catch (error) {
    console.warn(
      `copy-odhin-report: unable to write api-endpoints output: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

function injectNodeApiTab(reportFolder, endpoints, totalHits) {
  const files = fs
    .readdirSync(reportFolder)
    .filter((f) => f.toLowerCase().endsWith(".html"));
  const rows = endpoints.length
    ? endpoints
        .map(({ endpoint, hits }) => {
          const pct = totalHits ? ((hits / totalHits) * 100).toFixed(2) : "0.00";
          return `<tr>
        <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${endpoint}</td>
        <td class="text-secondary-emphasis">${hits}</td>
        <td class="text-secondary-emphasis">${pct}%</td>
      </tr>`;
        })
        .join("\n")
    : '<tr><td colspan="3" class="text-secondary-emphasis">No API endpoints found</td></tr>';

  const tabButton = `
\t\t\t\t\t\t<button
\t\t\t\t\t\t\tclass="main-tablinks"
\t\t\t\t\t\t\tonclick="openMainTab(event, 'TabNodeApi')"
\t\t\t\t\t\t>
\t\t\t\t\t\t\tTested Node.js API
\t\t\t\t\t\t</button>`;
  const tabPane = `
<div id="TabNodeApi" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Tested Node.js API endpoints</div>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            Counts come from apiClient/anonymousClient/client calls in Playwright node-api specs; percent is share of total calls.
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Endpoint</th>
                    <th class="odhin-text-3">Calls</th>
                    <th class="odhin-text-3">Percent of calls</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>`;

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, "utf8");
      if (html.includes('id="TabNodeApi"')) {
        return;
      }
      const tabBlock =
        /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
      if (tabBlock.test(html)) {
        html = html.replace(tabBlock, `$1${tabButton}$2`);
      }
      html = html.replace("</body>", `${tabPane}\n</body>`);
      fs.writeFileSync(fullPath, html, "utf8");
    } catch {
      // ignore
    }
  });
}
